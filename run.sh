#!/bin/bash

# 使用说明
usage() {
    echo "Usage: $0 -f <uploaded_zip_file> -d <dataset> -e <epochs> -n <net-name> -l <log-per-iter>"
    echo "Example: $0 -f ../IRSTD/data/1.32.zip -d IRSTD -e 100 -n resunet -l 10"
    exit 1
}

# 初始化变量
ZIP_FILE=""
DATASET=""
EPOCHS="200"
NET_NAME=""
LOG_PER_ITER="10"
USING_VALSET="0"
BATCH_SIZE="16"
BASE_SIZE="256"
LEARNING_RATE="0.001"
LEARNING_RATE_MIN="0.001"
MOD_RMD="0"
CHECK_POINT=""
LABEL_THRESHOLD="0.5"
GLOBAL_MIOU_START="0.5"

# 解析参数
while getopts "f:d:e:n:r:v:b:s:l:m:h:c:t:g:p" opt; do
    case $opt in
        f) ZIP_FILE="$OPTARG" ;;
        d) DATASET="$OPTARG" ;;
        e) EPOCHS="$OPTARG" ;;
        n) NET_NAME="$OPTARG" ;;
        r) LOG_PER_ITER="$OPTARG" ;;
        v) USING_VALSET="$OPTARG" ;;
        b) BATCH_SIZE="$OPTARG";;
        s) BASE_SIZE="$OPTARG";;
        l) LEARNING_RATE="$OPTARG";;
        m) MOD_RMD="$OPTARG";;
        h) LEARNING_RATE_MIN="$OPTARG";;
        c) CHECK_POINT="$OPTARG";;
        t) LABEL_THRESHOLD="$OPTARG";;
        g) GLOBAL_MIOU_START="$OPTARG";;
        *) usage ;;
    esac
done

# 检查必需参数
if [ -z "$ZIP_FILE" ]; then
    echo "Error: -f <zip_file> is required."
    usage
fi

# 保存当前工作目录（项目根目录）
ORIGINAL_DIR=$(pwd)

# Step 1: 检查 ZIP 文件是否存在
if [ ! -f "$ZIP_FILE" ]; then
    echo "Error: ZIP file $ZIP_FILE does not exist."
    exit 1
fi

# 获取绝对路径
ZIP_FILE_ABS=$(realpath "$ZIP_FILE")
ZIP_DIR=$(dirname "$ZIP_FILE_ABS")
ZIP_BASENAME=$(basename "$ZIP_FILE_ABS")

# 进入目录并解压
cd "$ZIP_DIR" || exit 1
echo "Unzipping $ZIP_BASENAME..."
unzip -q -n "$ZIP_BASENAME"
if [ $? -ne 0 ]; then
    echo "Error: Failed to unzip $ZIP_FILE"
    exit 1
fi

BASENAME="${ZIP_FILE%.zip}"
if [[ $BASENAME =~ pixel_pseudo_label([0-9]+\.[0-9]+(_[a-zA-Z]+)?)$ ]]; then
    TURN_NUM="${BASH_REMATCH[1]}"  # 组1 已经包含全部内容，无需拼接！
    echo "✅ SUCCESS: Extracted turn_num: $TURN_NUM"
else
    echo "❌ FAILED: Could not extract turn_num from '$BASENAME'. Using 'unknown'."
    TURN_NUM="unknown"
fi
echo "Extracted turn_num: $TURN_NUM"

# 回到项目根目录
cd "$ORIGINAL_DIR" || exit 1

# === 关键改进：创建唯一输出目录 ===
RESULT_DIR="./result"
OUTPUT_PREFIX="exp_$(date +%Y%m%d_%H%M%S)_$$"  # 时间戳 + PID，保证唯一性
OUTPUT_DIR="$RESULT_DIR/$OUTPUT_PREFIX"

# 创建输出目录
mkdir -p "$OUTPUT_DIR"
if [ $? -ne 0 ]; then
    echo "Error: Failed to create output directory $OUTPUT_DIR"
    exit 1
fi
echo "Created unique output directory: $OUTPUT_DIR"

# === 运行训练命令，传入 base-dir ===
echo "Running training..."
python train.py \
    --dataset "$DATASET" \
    --epochs "$EPOCHS" \
    --net-name "$NET_NAME" \
    --log-per-iter "$LOG_PER_ITER" \
    --turn-num "$TURN_NUM" \
    --batch-size "$BATCH_SIZE" \
    --valset "$USING_VALSET" \
    --base-size "$BASE_SIZE" \
    --base-dir "$OUTPUT_DIR" \
    --lr "$LEARNING_RATE" \
    --lr-min "$LEARNING_RATE_MIN" \
    --valset-rmd "$MOD_RMD" \
    --label-thre "$LABEL_THRESHOLD" \
    --global-miou "$GLOBAL_MIOU_START" \
    --model-path "$CHECK_POINT"

if [ $? -ne 0 ]; then
    echo "Error: Training script failed!"
    exit 1
fi

# === 训练结束后，查找 $OUTPUT_DIR 下的子文件夹 ===
echo "Looking for generated result subfolder in $OUTPUT_DIR..."

# 获取 $OUTPUT_DIR 下所有子目录（只取最后一级名称）
SUBFOLDERS=("$OUTPUT_DIR"/*/)

# 检查是否有子目录
if [ ${#SUBFOLDERS[@]} -eq 0 ] || [ ! -d "${SUBFOLDERS[0]}" ]; then
    echo "Error: No subfolder generated by training script in $OUTPUT_DIR"
    exit 1
fi

# 取第一个生成的子目录（也可以改成取最新的，见下方可选逻辑）
GENERATED_DIR="${SUBFOLDERS[0]}"
GENERATED_DIR_NAME=$(basename "$GENERATED_DIR")

echo "Detected generated folder: $GENERATED_DIR_NAME"

# === 打包这个子文件夹到 ./result/ 下 ===
TAR_FILE="$RESULT_DIR/${GENERATED_DIR_NAME}.tar"

echo "Compressing $GENERATED_DIR_NAME into $TAR_FILE..."
tar -cf "$TAR_FILE" -C "$OUTPUT_DIR" "$GENERATED_DIR_NAME"

if [ $? -ne 0 ]; then
    echo "Error: Failed to create tar archive $TAR_FILE"
    exit 1
fi

echo "Successfully created $TAR_FILE"

# 可选：将这个生成的文件夹也复制回 result 根目录（保留结构）
# 这样 .tar 和 原始文件夹都在 result/ 下
cp -r "$GENERATED_DIR" "$RESULT_DIR/" && echo "Copied $GENERATED_DIR_NAME back to $RESULT_DIR/"

# 清理临时目录（可选）
rm -rf "$OUTPUT_DIR"   # 删除整个临时目录

echo "Experiment completed. Result archived as $TAR_FILE"